// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/glop/parameters.proto

#include "ortools/glop/parameters.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace operations_research {
namespace glop {
constexpr GlopParameters::GlopParameters(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : use_dual_simplex_(false)
  , allow_simplex_algorithm_change_(false)
  , perturb_costs_in_dual_simplex_(false)
  , log_search_progress_(false)
  , use_implied_free_preprocessor_(true)
  , feasibility_rule_(1)

  , optimization_rule_(1)

  , refactorization_threshold_(1e-09)
  , recompute_reduced_costs_threshold_(1e-08)
  , recompute_edges_norm_threshold_(100)
  , primal_feasibility_tolerance_(1e-08)
  , dual_feasibility_tolerance_(1e-08)
  , ratio_test_zero_threshold_(1e-09)
  , harris_tolerance_ratio_(0.5)
  , small_pivot_threshold_(1e-06)
  , minimum_acceptable_pivot_(1e-06)
  , initial_basis_(2)

  , basis_refactorization_period_(64)
  , dualizer_threshold_(1.5)
  , solution_feasibility_tolerance_(1e-06)
  , solve_dual_problem_(2)

  , markowitz_zlatev_parameter_(3)
  , lu_factorization_pivot_threshold_(0.01)
  , max_time_in_seconds_(std::numeric_limits<double>::infinity())
  , max_number_of_iterations_(int64_t{-1})
  , markowitz_singularity_threshold_(1e-15)
  , use_scaling_(true)
  , use_transposed_matrix_(true)
  , dynamically_adjust_refactorization_period_(true)
  , provide_strong_optimal_guarantee_(true)
  , devex_weights_reset_period_(150)
  , dual_small_pivot_threshold_(0.0001)
  , preprocessor_zero_tolerance_(1e-09)
  , objective_lower_limit_(-std::numeric_limits<double>::infinity())
  , objective_upper_limit_(std::numeric_limits<double>::infinity())
  , change_status_to_imprecise_(true)
  , use_preprocessing_(true)
  , use_middle_product_form_update_(true)
  , initialize_devex_with_column_norms_(true)
  , random_seed_(1)
  , degenerate_ministep_factor_(0.01)
  , max_deterministic_time_(std::numeric_limits<double>::infinity())
  , num_omp_threads_(1)
  , scaling_method_(1)

  , drop_tolerance_(1e-14)
  , relative_cost_perturbation_(1e-05)
  , relative_max_cost_perturbation_(1e-07)
  , max_number_of_reoptimizations_(40)
  , exploit_singleton_column_in_initial_basis_(true)
  , use_dedicated_dual_feasibility_algorithm_(true)
  , log_to_stdout_(true)
  , push_to_vertex_(true)
  , cost_scaling_(1)

  , initial_condition_number_threshold_(1e+50)
  , crossover_bound_snapping_distance_(std::numeric_limits<double>::infinity())
  , max_valid_magnitude_(1e+30){}
struct GlopParametersDefaultTypeInternal {
  constexpr GlopParametersDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GlopParametersDefaultTypeInternal() {}
  union {
    GlopParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GlopParametersDefaultTypeInternal _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ortools_2fglop_2fparameters_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto = nullptr;

const uint32_t TableStruct_ortools_2fglop_2fparameters_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, scaling_method_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, feasibility_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, optimization_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, refactorization_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, recompute_reduced_costs_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, recompute_edges_norm_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, primal_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dual_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, ratio_test_zero_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, harris_tolerance_ratio_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, minimum_acceptable_pivot_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, drop_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_scaling_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, cost_scaling_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_transposed_matrix_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, basis_refactorization_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dynamically_adjust_refactorization_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, solve_dual_problem_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dualizer_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, solution_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, provide_strong_optimal_guarantee_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, change_status_to_imprecise_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_number_of_reoptimizations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, lu_factorization_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_time_in_seconds_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_deterministic_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_number_of_iterations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, markowitz_zlatev_parameter_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, markowitz_singularity_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, allow_simplex_algorithm_change_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, devex_weights_reset_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_preprocessing_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_middle_product_form_update_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initialize_devex_with_column_norms_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, exploit_singleton_column_in_initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dual_small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, preprocessor_zero_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, objective_lower_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, objective_upper_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, degenerate_ministep_factor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, random_seed_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, num_omp_threads_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, perturb_costs_in_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_dedicated_dual_feasibility_algorithm_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, relative_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, relative_max_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initial_condition_number_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, log_search_progress_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, log_to_stdout_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, crossover_bound_snapping_distance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, push_to_vertex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_implied_free_preprocessor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_valid_magnitude_),
  43,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  44,
  26,
  52,
  16,
  27,
  17,
  28,
  20,
  18,
  19,
  29,
  35,
  47,
  22,
  23,
  41,
  24,
  21,
  25,
  0,
  1,
  30,
  36,
  37,
  38,
  48,
  31,
  32,
  33,
  34,
  40,
  39,
  42,
  2,
  49,
  45,
  46,
  53,
  3,
  50,
  54,
  51,
  4,
  55,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 62, -1, sizeof(::operations_research::glop::GlopParameters)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::operations_research::glop::_GlopParameters_default_instance_),
};

const char descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035ortools/glop/parameters.proto\022\030operati"
  "ons_research.glop\"\207\030\n\016GlopParameters\022`\n\016"
  "scaling_method\0309 \001(\01629.operations_resear"
  "ch.glop.GlopParameters.ScalingAlgorithm:"
  "\rEQUILIBRATION\022]\n\020feasibility_rule\030\001 \001(\016"
  "24.operations_research.glop.GlopParamete"
  "rs.PricingRule:\rSTEEPEST_EDGE\022^\n\021optimiz"
  "ation_rule\030\002 \001(\01624.operations_research.g"
  "lop.GlopParameters.PricingRule:\rSTEEPEST"
  "_EDGE\022(\n\031refactorization_threshold\030\006 \001(\001"
  ":\0051e-09\0220\n!recompute_reduced_costs_thres"
  "hold\030\010 \001(\001:\0051e-08\022+\n\036recompute_edges_nor"
  "m_threshold\030\t \001(\001:\003100\022+\n\034primal_feasibi"
  "lity_tolerance\030\n \001(\001:\0051e-08\022)\n\032dual_feas"
  "ibility_tolerance\030\013 \001(\001:\0051e-08\022(\n\031ratio_"
  "test_zero_threshold\030\014 \001(\001:\0051e-09\022#\n\026harr"
  "is_tolerance_ratio\030\r \001(\001:\0030.5\022$\n\025small_p"
  "ivot_threshold\030\016 \001(\001:\0051e-06\022\'\n\030minimum_a"
  "cceptable_pivot\030\017 \001(\001:\0051e-06\022\035\n\016drop_tol"
  "erance\0304 \001(\001:\0051e-14\022\031\n\013use_scaling\030\020 \001(\010"
  ":\004true\022m\n\014cost_scaling\030< \001(\0162=.operation"
  "s_research.glop.GlopParameters.CostScali"
  "ngAlgorithm:\030CONTAIN_ONE_COST_SCALING\022a\n"
  "\rinitial_basis\030\021 \001(\0162>.operations_resear"
  "ch.glop.GlopParameters.InitialBasisHeuri"
  "stic:\nTRIANGULAR\022#\n\025use_transposed_matri"
  "x\030\022 \001(\010:\004true\022(\n\034basis_refactorization_p"
  "eriod\030\023 \001(\005:\00264\0227\n)dynamically_adjust_re"
  "factorization_period\030\? \001(\010:\004true\022f\n\022solv"
  "e_dual_problem\030\024 \001(\01627.operations_resear"
  "ch.glop.GlopParameters.SolverBehavior:\021L"
  "ET_SOLVER_DECIDE\022\037\n\022dualizer_threshold\030\025"
  " \001(\001:\0031.5\022-\n\036solution_feasibility_tolera"
  "nce\030\026 \001(\001:\0051e-06\022.\n provide_strong_optim"
  "al_guarantee\030\030 \001(\010:\004true\022(\n\032change_statu"
  "s_to_imprecise\030: \001(\010:\004true\022)\n\035max_number"
  "_of_reoptimizations\0308 \001(\001:\00240\022.\n lu_fact"
  "orization_pivot_threshold\030\031 \001(\001:\0040.01\022 \n"
  "\023max_time_in_seconds\030\032 \001(\001:\003inf\022#\n\026max_d"
  "eterministic_time\030- \001(\001:\003inf\022$\n\030max_numb"
  "er_of_iterations\030\033 \001(\003:\002-1\022%\n\032markowitz_"
  "zlatev_parameter\030\035 \001(\005:\0013\022.\n\037markowitz_s"
  "ingularity_threshold\030\036 \001(\001:\0051e-15\022\037\n\020use"
  "_dual_simplex\030\037 \001(\010:\005false\022-\n\036allow_simp"
  "lex_algorithm_change\030  \001(\010:\005false\022\'\n\032dev"
  "ex_weights_reset_period\030! \001(\005:\003150\022\037\n\021us"
  "e_preprocessing\030\" \001(\010:\004true\022,\n\036use_middl"
  "e_product_form_update\030# \001(\010:\004true\0220\n\"ini"
  "tialize_devex_with_column_norms\030$ \001(\010:\004t"
  "rue\0227\n)exploit_singleton_column_in_initi"
  "al_basis\030% \001(\010:\004true\022*\n\032dual_small_pivot"
  "_threshold\030& \001(\001:\0060.0001\022*\n\033preprocessor"
  "_zero_tolerance\030\' \001(\001:\0051e-09\022#\n\025objectiv"
  "e_lower_limit\030( \001(\001:\004-inf\022\"\n\025objective_u"
  "pper_limit\030) \001(\001:\003inf\022(\n\032degenerate_mini"
  "step_factor\030* \001(\001:\0040.01\022\026\n\013random_seed\030+"
  " \001(\005:\0011\022\032\n\017num_omp_threads\030, \001(\005:\0011\022,\n\035p"
  "erturb_costs_in_dual_simplex\0305 \001(\010:\005fals"
  "e\0226\n(use_dedicated_dual_feasibility_algo"
  "rithm\030> \001(\010:\004true\022)\n\032relative_cost_pertu"
  "rbation\0306 \001(\001:\0051e-05\022-\n\036relative_max_cos"
  "t_perturbation\0307 \001(\001:\0051e-07\0221\n\"initial_c"
  "ondition_number_threshold\030; \001(\001:\0051e+50\022\""
  "\n\023log_search_progress\030= \001(\010:\005false\022\033\n\rlo"
  "g_to_stdout\030B \001(\010:\004true\022.\n!crossover_bou"
  "nd_snapping_distance\030@ \001(\001:\003inf\022\034\n\016push_"
  "to_vertex\030A \001(\010:\004true\022+\n\035use_implied_fre"
  "e_preprocessor\030C \001(\010:\004true\022#\n\023max_valid_"
  "magnitude\030\307\001 \001(\001:\0051e+30\"F\n\020ScalingAlgori"
  "thm\022\013\n\007DEFAULT\020\000\022\021\n\rEQUILIBRATION\020\001\022\022\n\016L"
  "INEAR_PROGRAM\020\002\"D\n\016SolverBehavior\022\r\n\tALW"
  "AYS_DO\020\000\022\014\n\010NEVER_DO\020\001\022\025\n\021LET_SOLVER_DEC"
  "IDE\020\002\"8\n\013PricingRule\022\013\n\007DANTZIG\020\000\022\021\n\rSTE"
  "EPEST_EDGE\020\001\022\t\n\005DEVEX\020\002\"G\n\025InitialBasisH"
  "euristic\022\010\n\004NONE\020\000\022\t\n\005BIXBY\020\001\022\016\n\nTRIANGU"
  "LAR\020\002\022\t\n\005MAROS\020\003\"y\n\024CostScalingAlgorithm"
  "\022\023\n\017NO_COST_SCALING\020\000\022\034\n\030CONTAIN_ONE_COS"
  "T_SCALING\020\001\022\025\n\021MEAN_COST_SCALING\020\002\022\027\n\023ME"
  "DIAN_COST_SCALING\020\003B1\n\027com.google.ortool"
  "s.glopP\001\252\002\023Google.OrTools.Glop"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ortools_2fglop_2fparameters_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ortools_2fglop_2fparameters_2eproto = {
  false, false, 3190, descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto, "ortools/glop/parameters.proto", 
  &descriptor_table_ortools_2fglop_2fparameters_2eproto_once, nullptr, 0, 1,
  schemas, file_default_instances, TableStruct_ortools_2fglop_2fparameters_2eproto::offsets,
  file_level_metadata_ortools_2fglop_2fparameters_2eproto, file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto, file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_ortools_2fglop_2fparameters_2eproto_getter() {
  return &descriptor_table_ortools_2fglop_2fparameters_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_ortools_2fglop_2fparameters_2eproto(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
namespace operations_research {
namespace glop {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_ScalingAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[0];
}
bool GlopParameters_ScalingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_ScalingAlgorithm GlopParameters::DEFAULT;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::EQUILIBRATION;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::LINEAR_PROGRAM;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MIN;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MAX;
constexpr int GlopParameters::ScalingAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_SolverBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[1];
}
bool GlopParameters_SolverBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_SolverBehavior GlopParameters::ALWAYS_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::NEVER_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::LET_SOLVER_DECIDE;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MIN;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MAX;
constexpr int GlopParameters::SolverBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_PricingRule_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[2];
}
bool GlopParameters_PricingRule_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_PricingRule GlopParameters::DANTZIG;
constexpr GlopParameters_PricingRule GlopParameters::STEEPEST_EDGE;
constexpr GlopParameters_PricingRule GlopParameters::DEVEX;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MIN;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MAX;
constexpr int GlopParameters::PricingRule_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_InitialBasisHeuristic_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[3];
}
bool GlopParameters_InitialBasisHeuristic_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::NONE;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::BIXBY;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::TRIANGULAR;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::MAROS;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MIN;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MAX;
constexpr int GlopParameters::InitialBasisHeuristic_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_CostScalingAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[4];
}
bool GlopParameters_CostScalingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::NO_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CONTAIN_ONE_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::MEAN_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::MEDIAN_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CostScalingAlgorithm_MIN;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CostScalingAlgorithm_MAX;
constexpr int GlopParameters::CostScalingAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class GlopParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<GlopParameters>()._has_bits_);
  static void set_has_scaling_method(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_feasibility_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_optimization_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_refactorization_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_recompute_reduced_costs_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_recompute_edges_norm_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_primal_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_dual_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_ratio_test_zero_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_harris_tolerance_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_minimum_acceptable_pivot(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_drop_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_use_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_cost_scaling(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_initial_basis(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_use_transposed_matrix(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_basis_refactorization_period(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_dynamically_adjust_refactorization_period(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_solve_dual_problem(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_dualizer_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_solution_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_provide_strong_optimal_guarantee(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_change_status_to_imprecise(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_max_number_of_reoptimizations(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_lu_factorization_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_max_time_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_max_deterministic_time(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_max_number_of_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_markowitz_zlatev_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_markowitz_singularity_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_use_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_simplex_algorithm_change(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_devex_weights_reset_period(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_use_preprocessing(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_use_middle_product_form_update(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_initialize_devex_with_column_norms(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_exploit_singleton_column_in_initial_basis(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_dual_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_preprocessor_zero_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_objective_lower_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_objective_upper_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_degenerate_ministep_factor(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_num_omp_threads(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_perturb_costs_in_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_use_dedicated_dual_feasibility_algorithm(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_relative_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_relative_max_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_initial_condition_number_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_log_search_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_log_to_stdout(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_crossover_bound_snapping_distance(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_push_to_vertex(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_use_implied_free_preprocessor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_valid_magnitude(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
};

GlopParameters::GlopParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:operations_research.glop.GlopParameters)
}
GlopParameters::GlopParameters(const GlopParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&use_dual_simplex_, &from.use_dual_simplex_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_valid_magnitude_) -
    reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(max_valid_magnitude_));
  // @@protoc_insertion_point(copy_constructor:operations_research.glop.GlopParameters)
}

inline void GlopParameters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&use_dual_simplex_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&log_search_progress_) -
    reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(log_search_progress_));
use_implied_free_preprocessor_ = true;
feasibility_rule_ = 1;
optimization_rule_ = 1;
refactorization_threshold_ = 1e-09;
recompute_reduced_costs_threshold_ = 1e-08;
recompute_edges_norm_threshold_ = 100;
primal_feasibility_tolerance_ = 1e-08;
dual_feasibility_tolerance_ = 1e-08;
ratio_test_zero_threshold_ = 1e-09;
harris_tolerance_ratio_ = 0.5;
small_pivot_threshold_ = 1e-06;
minimum_acceptable_pivot_ = 1e-06;
initial_basis_ = 2;
basis_refactorization_period_ = 64;
dualizer_threshold_ = 1.5;
solution_feasibility_tolerance_ = 1e-06;
solve_dual_problem_ = 2;
markowitz_zlatev_parameter_ = 3;
lu_factorization_pivot_threshold_ = 0.01;
max_time_in_seconds_ = std::numeric_limits<double>::infinity();
max_number_of_iterations_ = int64_t{-1};
markowitz_singularity_threshold_ = 1e-15;
use_scaling_ = true;
use_transposed_matrix_ = true;
dynamically_adjust_refactorization_period_ = true;
provide_strong_optimal_guarantee_ = true;
devex_weights_reset_period_ = 150;
dual_small_pivot_threshold_ = 0.0001;
preprocessor_zero_tolerance_ = 1e-09;
objective_lower_limit_ = -std::numeric_limits<double>::infinity();
objective_upper_limit_ = std::numeric_limits<double>::infinity();
change_status_to_imprecise_ = true;
use_preprocessing_ = true;
use_middle_product_form_update_ = true;
initialize_devex_with_column_norms_ = true;
random_seed_ = 1;
degenerate_ministep_factor_ = 0.01;
max_deterministic_time_ = std::numeric_limits<double>::infinity();
num_omp_threads_ = 1;
scaling_method_ = 1;
drop_tolerance_ = 1e-14;
relative_cost_perturbation_ = 1e-05;
relative_max_cost_perturbation_ = 1e-07;
max_number_of_reoptimizations_ = 40;
exploit_singleton_column_in_initial_basis_ = true;
use_dedicated_dual_feasibility_algorithm_ = true;
log_to_stdout_ = true;
push_to_vertex_ = true;
cost_scaling_ = 1;
initial_condition_number_threshold_ = 1e+50;
crossover_bound_snapping_distance_ = std::numeric_limits<double>::infinity();
max_valid_magnitude_ = 1e+30;
}

GlopParameters::~GlopParameters() {
  // @@protoc_insertion_point(destructor:operations_research.glop.GlopParameters)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GlopParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GlopParameters::ArenaDtor(void* object) {
  GlopParameters* _this = reinterpret_cast< GlopParameters* >(object);
  (void)_this;
}
void GlopParameters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GlopParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GlopParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.glop.GlopParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&use_dual_simplex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&log_search_progress_) -
      reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(log_search_progress_));
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000f0u) {
    use_implied_free_preprocessor_ = true;
    feasibility_rule_ = 1;
    optimization_rule_ = 1;
    refactorization_threshold_ = 1e-09;
  }
  if (cached_has_bits & 0x0000ff00u) {
    recompute_reduced_costs_threshold_ = 1e-08;
    recompute_edges_norm_threshold_ = 100;
    primal_feasibility_tolerance_ = 1e-08;
    dual_feasibility_tolerance_ = 1e-08;
    ratio_test_zero_threshold_ = 1e-09;
    harris_tolerance_ratio_ = 0.5;
    small_pivot_threshold_ = 1e-06;
    minimum_acceptable_pivot_ = 1e-06;
  }
  if (cached_has_bits & 0x00ff0000u) {
    initial_basis_ = 2;
    basis_refactorization_period_ = 64;
    dualizer_threshold_ = 1.5;
    solution_feasibility_tolerance_ = 1e-06;
    solve_dual_problem_ = 2;
    markowitz_zlatev_parameter_ = 3;
    lu_factorization_pivot_threshold_ = 0.01;
    max_time_in_seconds_ = std::numeric_limits<double>::infinity();
  }
  if (cached_has_bits & 0xff000000u) {
    max_number_of_iterations_ = int64_t{-1};
    markowitz_singularity_threshold_ = 1e-15;
    use_scaling_ = true;
    use_transposed_matrix_ = true;
    dynamically_adjust_refactorization_period_ = true;
    provide_strong_optimal_guarantee_ = true;
    devex_weights_reset_period_ = 150;
    dual_small_pivot_threshold_ = 0.0001;
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    preprocessor_zero_tolerance_ = 1e-09;
    objective_lower_limit_ = -std::numeric_limits<double>::infinity();
    objective_upper_limit_ = std::numeric_limits<double>::infinity();
    change_status_to_imprecise_ = true;
    use_preprocessing_ = true;
    use_middle_product_form_update_ = true;
    initialize_devex_with_column_norms_ = true;
    random_seed_ = 1;
  }
  if (cached_has_bits & 0x0000ff00u) {
    degenerate_ministep_factor_ = 0.01;
    max_deterministic_time_ = std::numeric_limits<double>::infinity();
    num_omp_threads_ = 1;
    scaling_method_ = 1;
    drop_tolerance_ = 1e-14;
    relative_cost_perturbation_ = 1e-05;
    relative_max_cost_perturbation_ = 1e-07;
    max_number_of_reoptimizations_ = 40;
  }
  if (cached_has_bits & 0x00ff0000u) {
    exploit_singleton_column_in_initial_basis_ = true;
    use_dedicated_dual_feasibility_algorithm_ = true;
    log_to_stdout_ = true;
    push_to_vertex_ = true;
    cost_scaling_ = 1;
    initial_condition_number_threshold_ = 1e+50;
    crossover_bound_snapping_distance_ = std::numeric_limits<double>::infinity();
    max_valid_magnitude_ = 1e+30;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlopParameters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_feasibility_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_optimization_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double refactorization_threshold = 6 [default = 1e-09];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_refactorization_threshold(&_has_bits_);
          refactorization_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_recompute_reduced_costs_threshold(&_has_bits_);
          recompute_reduced_costs_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double recompute_edges_norm_threshold = 9 [default = 100];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_recompute_edges_norm_threshold(&_has_bits_);
          recompute_edges_norm_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_primal_feasibility_tolerance(&_has_bits_);
          primal_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_dual_feasibility_tolerance(&_has_bits_);
          dual_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_ratio_test_zero_threshold(&_has_bits_);
          ratio_test_zero_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double harris_tolerance_ratio = 13 [default = 0.5];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_harris_tolerance_ratio(&_has_bits_);
          harris_tolerance_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double small_pivot_threshold = 14 [default = 1e-06];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_small_pivot_threshold(&_has_bits_);
          small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _Internal::set_has_minimum_acceptable_pivot(&_has_bits_);
          minimum_acceptable_pivot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_scaling = 16 [default = true];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_use_scaling(&_has_bits_);
          use_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_InitialBasisHeuristic_IsValid(val))) {
            _internal_set_initial_basis(static_cast<::operations_research::glop::GlopParameters_InitialBasisHeuristic>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool use_transposed_matrix = 18 [default = true];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_use_transposed_matrix(&_has_bits_);
          use_transposed_matrix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 basis_refactorization_period = 19 [default = 64];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_basis_refactorization_period(&_has_bits_);
          basis_refactorization_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_SolverBehavior_IsValid(val))) {
            _internal_set_solve_dual_problem(static_cast<::operations_research::glop::GlopParameters_SolverBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double dualizer_threshold = 21 [default = 1.5];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _Internal::set_has_dualizer_threshold(&_has_bits_);
          dualizer_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_solution_feasibility_tolerance(&_has_bits_);
          solution_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool provide_strong_optimal_guarantee = 24 [default = true];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_provide_strong_optimal_guarantee(&_has_bits_);
          provide_strong_optimal_guarantee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          _Internal::set_has_lu_factorization_pivot_threshold(&_has_bits_);
          lu_factorization_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_time_in_seconds = 26 [default = inf];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          _Internal::set_has_max_time_in_seconds(&_has_bits_);
          max_time_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_number_of_iterations = 27 [default = -1];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_max_number_of_iterations(&_has_bits_);
          max_number_of_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_markowitz_zlatev_parameter(&_has_bits_);
          markowitz_zlatev_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          _Internal::set_has_markowitz_singularity_threshold(&_has_bits_);
          markowitz_singularity_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_dual_simplex = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_use_dual_simplex(&_has_bits_);
          use_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_simplex_algorithm_change = 32 [default = false];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_allow_simplex_algorithm_change(&_has_bits_);
          allow_simplex_algorithm_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 devex_weights_reset_period = 33 [default = 150];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_devex_weights_reset_period(&_has_bits_);
          devex_weights_reset_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_preprocessing = 34 [default = true];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_preprocessing(&_has_bits_);
          use_preprocessing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_middle_product_form_update = 35 [default = true];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_use_middle_product_form_update(&_has_bits_);
          use_middle_product_form_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool initialize_devex_with_column_norms = 36 [default = true];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_initialize_devex_with_column_norms(&_has_bits_);
          initialize_devex_with_column_norms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_exploit_singleton_column_in_initial_basis(&_has_bits_);
          exploit_singleton_column_in_initial_basis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_dual_small_pivot_threshold(&_has_bits_);
          dual_small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_preprocessor_zero_tolerance(&_has_bits_);
          preprocessor_zero_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double objective_lower_limit = 40 [default = -inf];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_objective_lower_limit(&_has_bits_);
          objective_lower_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double objective_upper_limit = 41 [default = inf];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_objective_upper_limit(&_has_bits_);
          objective_upper_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double degenerate_ministep_factor = 42 [default = 0.01];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_degenerate_ministep_factor(&_has_bits_);
          degenerate_ministep_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 43 [default = 1];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_random_seed(&_has_bits_);
          random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_omp_threads = 44 [default = 1];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_num_omp_threads(&_has_bits_);
          num_omp_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_deterministic_time = 45 [default = inf];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_max_deterministic_time(&_has_bits_);
          max_deterministic_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double drop_tolerance = 52 [default = 1e-14];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _Internal::set_has_drop_tolerance(&_has_bits_);
          drop_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_perturb_costs_in_dual_simplex(&_has_bits_);
          perturb_costs_in_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double relative_cost_perturbation = 54 [default = 1e-05];
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_relative_cost_perturbation(&_has_bits_);
          relative_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _Internal::set_has_relative_max_cost_perturbation(&_has_bits_);
          relative_max_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_number_of_reoptimizations = 56 [default = 40];
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          _Internal::set_has_max_number_of_reoptimizations(&_has_bits_);
          max_number_of_reoptimizations_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_ScalingAlgorithm_IsValid(val))) {
            _internal_set_scaling_method(static_cast<::operations_research::glop::GlopParameters_ScalingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(57, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool change_status_to_imprecise = 58 [default = true];
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_change_status_to_imprecise(&_has_bits_);
          change_status_to_imprecise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double initial_condition_number_threshold = 59 [default = 1e+50];
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _Internal::set_has_initial_condition_number_threshold(&_has_bits_);
          initial_condition_number_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_CostScalingAlgorithm_IsValid(val))) {
            _internal_set_cost_scaling(static_cast<::operations_research::glop::GlopParameters_CostScalingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(60, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool log_search_progress = 61 [default = false];
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_log_search_progress(&_has_bits_);
          log_search_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_use_dedicated_dual_feasibility_algorithm(&_has_bits_);
          use_dedicated_dual_feasibility_algorithm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_dynamically_adjust_refactorization_period(&_has_bits_);
          dynamically_adjust_refactorization_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double crossover_bound_snapping_distance = 64 [default = inf];
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          _Internal::set_has_crossover_bound_snapping_distance(&_has_bits_);
          crossover_bound_snapping_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool push_to_vertex = 65 [default = true];
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_push_to_vertex(&_has_bits_);
          push_to_vertex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool log_to_stdout = 66 [default = true];
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_log_to_stdout(&_has_bits_);
          log_to_stdout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_implied_free_preprocessor = 67 [default = true];
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_use_implied_free_preprocessor(&_has_bits_);
          use_implied_free_preprocessor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_magnitude = 199 [default = 1e+30];
      case 199:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_max_valid_magnitude(&_has_bits_);
          max_valid_magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlopParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.glop.GlopParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_feasibility_rule(), target);
  }

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_optimization_rule(), target);
  }

  // optional double refactorization_threshold = 6 [default = 1e-09];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_refactorization_threshold(), target);
  }

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_recompute_reduced_costs_threshold(), target);
  }

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_recompute_edges_norm_threshold(), target);
  }

  // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_primal_feasibility_tolerance(), target);
  }

  // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_dual_feasibility_tolerance(), target);
  }

  // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_ratio_test_zero_threshold(), target);
  }

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_harris_tolerance_ratio(), target);
  }

  // optional double small_pivot_threshold = 14 [default = 1e-06];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_small_pivot_threshold(), target);
  }

  // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(15, this->_internal_minimum_acceptable_pivot(), target);
  }

  // optional bool use_scaling = 16 [default = true];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_use_scaling(), target);
  }

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      17, this->_internal_initial_basis(), target);
  }

  // optional bool use_transposed_matrix = 18 [default = true];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_use_transposed_matrix(), target);
  }

  // optional int32 basis_refactorization_period = 19 [default = 64];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_basis_refactorization_period(), target);
  }

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_solve_dual_problem(), target);
  }

  // optional double dualizer_threshold = 21 [default = 1.5];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_dualizer_threshold(), target);
  }

  // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(22, this->_internal_solution_feasibility_tolerance(), target);
  }

  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_provide_strong_optimal_guarantee(), target);
  }

  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(25, this->_internal_lu_factorization_pivot_threshold(), target);
  }

  // optional double max_time_in_seconds = 26 [default = inf];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(26, this->_internal_max_time_in_seconds(), target);
  }

  // optional int64 max_number_of_iterations = 27 [default = -1];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(27, this->_internal_max_number_of_iterations(), target);
  }

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_markowitz_zlatev_parameter(), target);
  }

  // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(30, this->_internal_markowitz_singularity_threshold(), target);
  }

  // optional bool use_dual_simplex = 31 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_use_dual_simplex(), target);
  }

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_allow_simplex_algorithm_change(), target);
  }

  // optional int32 devex_weights_reset_period = 33 [default = 150];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(33, this->_internal_devex_weights_reset_period(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_preprocessing = 34 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(34, this->_internal_use_preprocessing(), target);
  }

  // optional bool use_middle_product_form_update = 35 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(35, this->_internal_use_middle_product_form_update(), target);
  }

  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(36, this->_internal_initialize_devex_with_column_norms(), target);
  }

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(37, this->_internal_exploit_singleton_column_in_initial_basis(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(38, this->_internal_dual_small_pivot_threshold(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(39, this->_internal_preprocessor_zero_tolerance(), target);
  }

  // optional double objective_lower_limit = 40 [default = -inf];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(40, this->_internal_objective_lower_limit(), target);
  }

  // optional double objective_upper_limit = 41 [default = inf];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(41, this->_internal_objective_upper_limit(), target);
  }

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(42, this->_internal_degenerate_ministep_factor(), target);
  }

  // optional int32 random_seed = 43 [default = 1];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(43, this->_internal_random_seed(), target);
  }

  // optional int32 num_omp_threads = 44 [default = 1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(44, this->_internal_num_omp_threads(), target);
  }

  // optional double max_deterministic_time = 45 [default = inf];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(45, this->_internal_max_deterministic_time(), target);
  }

  // optional double drop_tolerance = 52 [default = 1e-14];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(52, this->_internal_drop_tolerance(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(53, this->_internal_perturb_costs_in_dual_simplex(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double relative_cost_perturbation = 54 [default = 1e-05];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(54, this->_internal_relative_cost_perturbation(), target);
  }

  // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(55, this->_internal_relative_max_cost_perturbation(), target);
  }

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(56, this->_internal_max_number_of_reoptimizations(), target);
  }

  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      57, this->_internal_scaling_method(), target);
  }

  // optional bool change_status_to_imprecise = 58 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(58, this->_internal_change_status_to_imprecise(), target);
  }

  // optional double initial_condition_number_threshold = 59 [default = 1e+50];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(59, this->_internal_initial_condition_number_threshold(), target);
  }

  // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      60, this->_internal_cost_scaling(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool log_search_progress = 61 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(61, this->_internal_log_search_progress(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(62, this->_internal_use_dedicated_dual_feasibility_algorithm(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(63, this->_internal_dynamically_adjust_refactorization_period(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double crossover_bound_snapping_distance = 64 [default = inf];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(64, this->_internal_crossover_bound_snapping_distance(), target);
  }

  // optional bool push_to_vertex = 65 [default = true];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(65, this->_internal_push_to_vertex(), target);
  }

  // optional bool log_to_stdout = 66 [default = true];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(66, this->_internal_log_to_stdout(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool use_implied_free_preprocessor = 67 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(67, this->_internal_use_implied_free_preprocessor(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double max_valid_magnitude = 199 [default = 1e+30];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(199, this->_internal_max_valid_magnitude(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.glop.GlopParameters)
  return target;
}

size_t GlopParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.glop.GlopParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool use_dual_simplex = 31 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool allow_simplex_algorithm_change = 32 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional bool log_search_progress = 61 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool use_implied_free_preprocessor = 67 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_feasibility_rule());
    }

    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_optimization_rule());
    }

    // optional double refactorization_threshold = 6 [default = 1e-09];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double recompute_edges_norm_threshold = 9 [default = 100];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double harris_tolerance_ratio = 13 [default = 0.5];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double small_pivot_threshold = 14 [default = 1e-06];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_initial_basis());
    }

    // optional int32 basis_refactorization_period = 19 [default = 64];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_basis_refactorization_period());
    }

    // optional double dualizer_threshold = 21 [default = 1.5];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_solve_dual_problem());
    }

    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_markowitz_zlatev_parameter());
    }

    // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double max_time_in_seconds = 26 [default = inf];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int64 max_number_of_iterations = 27 [default = -1];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_max_number_of_iterations());
    }

    // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional bool use_scaling = 16 [default = true];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool use_transposed_matrix = 18 [default = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool provide_strong_optimal_guarantee = 24 [default = true];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional int32 devex_weights_reset_period = 33 [default = 150];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_devex_weights_reset_period());
    }

    // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 8;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 8;
    }

    // optional double objective_lower_limit = 40 [default = -inf];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 8;
    }

    // optional double objective_upper_limit = 41 [default = inf];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 8;
    }

    // optional bool change_status_to_imprecise = 58 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool use_preprocessing = 34 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool use_middle_product_form_update = 35 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool initialize_devex_with_column_norms = 36 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional int32 random_seed = 43 [default = 1];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_random_seed());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double degenerate_ministep_factor = 42 [default = 0.01];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 8;
    }

    // optional double max_deterministic_time = 45 [default = inf];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 8;
    }

    // optional int32 num_omp_threads = 44 [default = 1];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_omp_threads());
    }

    // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_scaling_method());
    }

    // optional double drop_tolerance = 52 [default = 1e-14];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional double relative_cost_perturbation = 54 [default = 1e-05];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 8;
    }

    // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 8;
    }

    // optional double max_number_of_reoptimizations = 56 [default = 40];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool log_to_stdout = 66 [default = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool push_to_vertex = 65 [default = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cost_scaling());
    }

    // optional double initial_condition_number_threshold = 59 [default = 1e+50];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional double crossover_bound_snapping_distance = 64 [default = inf];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double max_valid_magnitude = 199 [default = 1e+30];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlopParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GlopParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlopParameters::GetClassData() const { return &_class_data_; }

void GlopParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GlopParameters *>(to)->MergeFrom(
      static_cast<const GlopParameters &>(from));
}


void GlopParameters::MergeFrom(const GlopParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:operations_research.glop.GlopParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      use_dual_simplex_ = from.use_dual_simplex_;
    }
    if (cached_has_bits & 0x00000002u) {
      allow_simplex_algorithm_change_ = from.allow_simplex_algorithm_change_;
    }
    if (cached_has_bits & 0x00000004u) {
      perturb_costs_in_dual_simplex_ = from.perturb_costs_in_dual_simplex_;
    }
    if (cached_has_bits & 0x00000008u) {
      log_search_progress_ = from.log_search_progress_;
    }
    if (cached_has_bits & 0x00000010u) {
      use_implied_free_preprocessor_ = from.use_implied_free_preprocessor_;
    }
    if (cached_has_bits & 0x00000020u) {
      feasibility_rule_ = from.feasibility_rule_;
    }
    if (cached_has_bits & 0x00000040u) {
      optimization_rule_ = from.optimization_rule_;
    }
    if (cached_has_bits & 0x00000080u) {
      refactorization_threshold_ = from.refactorization_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      recompute_reduced_costs_threshold_ = from.recompute_reduced_costs_threshold_;
    }
    if (cached_has_bits & 0x00000200u) {
      recompute_edges_norm_threshold_ = from.recompute_edges_norm_threshold_;
    }
    if (cached_has_bits & 0x00000400u) {
      primal_feasibility_tolerance_ = from.primal_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00000800u) {
      dual_feasibility_tolerance_ = from.dual_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00001000u) {
      ratio_test_zero_threshold_ = from.ratio_test_zero_threshold_;
    }
    if (cached_has_bits & 0x00002000u) {
      harris_tolerance_ratio_ = from.harris_tolerance_ratio_;
    }
    if (cached_has_bits & 0x00004000u) {
      small_pivot_threshold_ = from.small_pivot_threshold_;
    }
    if (cached_has_bits & 0x00008000u) {
      minimum_acceptable_pivot_ = from.minimum_acceptable_pivot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      initial_basis_ = from.initial_basis_;
    }
    if (cached_has_bits & 0x00020000u) {
      basis_refactorization_period_ = from.basis_refactorization_period_;
    }
    if (cached_has_bits & 0x00040000u) {
      dualizer_threshold_ = from.dualizer_threshold_;
    }
    if (cached_has_bits & 0x00080000u) {
      solution_feasibility_tolerance_ = from.solution_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00100000u) {
      solve_dual_problem_ = from.solve_dual_problem_;
    }
    if (cached_has_bits & 0x00200000u) {
      markowitz_zlatev_parameter_ = from.markowitz_zlatev_parameter_;
    }
    if (cached_has_bits & 0x00400000u) {
      lu_factorization_pivot_threshold_ = from.lu_factorization_pivot_threshold_;
    }
    if (cached_has_bits & 0x00800000u) {
      max_time_in_seconds_ = from.max_time_in_seconds_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      max_number_of_iterations_ = from.max_number_of_iterations_;
    }
    if (cached_has_bits & 0x02000000u) {
      markowitz_singularity_threshold_ = from.markowitz_singularity_threshold_;
    }
    if (cached_has_bits & 0x04000000u) {
      use_scaling_ = from.use_scaling_;
    }
    if (cached_has_bits & 0x08000000u) {
      use_transposed_matrix_ = from.use_transposed_matrix_;
    }
    if (cached_has_bits & 0x10000000u) {
      dynamically_adjust_refactorization_period_ = from.dynamically_adjust_refactorization_period_;
    }
    if (cached_has_bits & 0x20000000u) {
      provide_strong_optimal_guarantee_ = from.provide_strong_optimal_guarantee_;
    }
    if (cached_has_bits & 0x40000000u) {
      devex_weights_reset_period_ = from.devex_weights_reset_period_;
    }
    if (cached_has_bits & 0x80000000u) {
      dual_small_pivot_threshold_ = from.dual_small_pivot_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      preprocessor_zero_tolerance_ = from.preprocessor_zero_tolerance_;
    }
    if (cached_has_bits & 0x00000002u) {
      objective_lower_limit_ = from.objective_lower_limit_;
    }
    if (cached_has_bits & 0x00000004u) {
      objective_upper_limit_ = from.objective_upper_limit_;
    }
    if (cached_has_bits & 0x00000008u) {
      change_status_to_imprecise_ = from.change_status_to_imprecise_;
    }
    if (cached_has_bits & 0x00000010u) {
      use_preprocessing_ = from.use_preprocessing_;
    }
    if (cached_has_bits & 0x00000020u) {
      use_middle_product_form_update_ = from.use_middle_product_form_update_;
    }
    if (cached_has_bits & 0x00000040u) {
      initialize_devex_with_column_norms_ = from.initialize_devex_with_column_norms_;
    }
    if (cached_has_bits & 0x00000080u) {
      random_seed_ = from.random_seed_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      degenerate_ministep_factor_ = from.degenerate_ministep_factor_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_deterministic_time_ = from.max_deterministic_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      num_omp_threads_ = from.num_omp_threads_;
    }
    if (cached_has_bits & 0x00000800u) {
      scaling_method_ = from.scaling_method_;
    }
    if (cached_has_bits & 0x00001000u) {
      drop_tolerance_ = from.drop_tolerance_;
    }
    if (cached_has_bits & 0x00002000u) {
      relative_cost_perturbation_ = from.relative_cost_perturbation_;
    }
    if (cached_has_bits & 0x00004000u) {
      relative_max_cost_perturbation_ = from.relative_max_cost_perturbation_;
    }
    if (cached_has_bits & 0x00008000u) {
      max_number_of_reoptimizations_ = from.max_number_of_reoptimizations_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      exploit_singleton_column_in_initial_basis_ = from.exploit_singleton_column_in_initial_basis_;
    }
    if (cached_has_bits & 0x00020000u) {
      use_dedicated_dual_feasibility_algorithm_ = from.use_dedicated_dual_feasibility_algorithm_;
    }
    if (cached_has_bits & 0x00040000u) {
      log_to_stdout_ = from.log_to_stdout_;
    }
    if (cached_has_bits & 0x00080000u) {
      push_to_vertex_ = from.push_to_vertex_;
    }
    if (cached_has_bits & 0x00100000u) {
      cost_scaling_ = from.cost_scaling_;
    }
    if (cached_has_bits & 0x00200000u) {
      initial_condition_number_threshold_ = from.initial_condition_number_threshold_;
    }
    if (cached_has_bits & 0x00400000u) {
      crossover_bound_snapping_distance_ = from.crossover_bound_snapping_distance_;
    }
    if (cached_has_bits & 0x00800000u) {
      max_valid_magnitude_ = from.max_valid_magnitude_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlopParameters::CopyFrom(const GlopParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.glop.GlopParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlopParameters::IsInitialized() const {
  return true;
}

void GlopParameters::InternalSwap(GlopParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlopParameters, log_search_progress_)
      + sizeof(GlopParameters::log_search_progress_)
      - PROTOBUF_FIELD_OFFSET(GlopParameters, use_dual_simplex_)>(
          reinterpret_cast<char*>(&use_dual_simplex_),
          reinterpret_cast<char*>(&other->use_dual_simplex_));
  swap(use_implied_free_preprocessor_, other->use_implied_free_preprocessor_);
  swap(feasibility_rule_, other->feasibility_rule_);
  swap(optimization_rule_, other->optimization_rule_);
  swap(refactorization_threshold_, other->refactorization_threshold_);
  swap(recompute_reduced_costs_threshold_, other->recompute_reduced_costs_threshold_);
  swap(recompute_edges_norm_threshold_, other->recompute_edges_norm_threshold_);
  swap(primal_feasibility_tolerance_, other->primal_feasibility_tolerance_);
  swap(dual_feasibility_tolerance_, other->dual_feasibility_tolerance_);
  swap(ratio_test_zero_threshold_, other->ratio_test_zero_threshold_);
  swap(harris_tolerance_ratio_, other->harris_tolerance_ratio_);
  swap(small_pivot_threshold_, other->small_pivot_threshold_);
  swap(minimum_acceptable_pivot_, other->minimum_acceptable_pivot_);
  swap(initial_basis_, other->initial_basis_);
  swap(basis_refactorization_period_, other->basis_refactorization_period_);
  swap(dualizer_threshold_, other->dualizer_threshold_);
  swap(solution_feasibility_tolerance_, other->solution_feasibility_tolerance_);
  swap(solve_dual_problem_, other->solve_dual_problem_);
  swap(markowitz_zlatev_parameter_, other->markowitz_zlatev_parameter_);
  swap(lu_factorization_pivot_threshold_, other->lu_factorization_pivot_threshold_);
  swap(max_time_in_seconds_, other->max_time_in_seconds_);
  swap(max_number_of_iterations_, other->max_number_of_iterations_);
  swap(markowitz_singularity_threshold_, other->markowitz_singularity_threshold_);
  swap(use_scaling_, other->use_scaling_);
  swap(use_transposed_matrix_, other->use_transposed_matrix_);
  swap(dynamically_adjust_refactorization_period_, other->dynamically_adjust_refactorization_period_);
  swap(provide_strong_optimal_guarantee_, other->provide_strong_optimal_guarantee_);
  swap(devex_weights_reset_period_, other->devex_weights_reset_period_);
  swap(dual_small_pivot_threshold_, other->dual_small_pivot_threshold_);
  swap(preprocessor_zero_tolerance_, other->preprocessor_zero_tolerance_);
  swap(objective_lower_limit_, other->objective_lower_limit_);
  swap(objective_upper_limit_, other->objective_upper_limit_);
  swap(change_status_to_imprecise_, other->change_status_to_imprecise_);
  swap(use_preprocessing_, other->use_preprocessing_);
  swap(use_middle_product_form_update_, other->use_middle_product_form_update_);
  swap(initialize_devex_with_column_norms_, other->initialize_devex_with_column_norms_);
  swap(random_seed_, other->random_seed_);
  swap(degenerate_ministep_factor_, other->degenerate_ministep_factor_);
  swap(max_deterministic_time_, other->max_deterministic_time_);
  swap(num_omp_threads_, other->num_omp_threads_);
  swap(scaling_method_, other->scaling_method_);
  swap(drop_tolerance_, other->drop_tolerance_);
  swap(relative_cost_perturbation_, other->relative_cost_perturbation_);
  swap(relative_max_cost_perturbation_, other->relative_max_cost_perturbation_);
  swap(max_number_of_reoptimizations_, other->max_number_of_reoptimizations_);
  swap(exploit_singleton_column_in_initial_basis_, other->exploit_singleton_column_in_initial_basis_);
  swap(use_dedicated_dual_feasibility_algorithm_, other->use_dedicated_dual_feasibility_algorithm_);
  swap(log_to_stdout_, other->log_to_stdout_);
  swap(push_to_vertex_, other->push_to_vertex_);
  swap(cost_scaling_, other->cost_scaling_);
  swap(initial_condition_number_threshold_, other->initial_condition_number_threshold_);
  swap(crossover_bound_snapping_distance_, other->crossover_bound_snapping_distance_);
  swap(max_valid_magnitude_, other->max_valid_magnitude_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlopParameters::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ortools_2fglop_2fparameters_2eproto_getter, &descriptor_table_ortools_2fglop_2fparameters_2eproto_once,
      file_level_metadata_ortools_2fglop_2fparameters_2eproto[0]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace glop
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::operations_research::glop::GlopParameters* Arena::CreateMaybeMessage< ::operations_research::glop::GlopParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::glop::GlopParameters >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
